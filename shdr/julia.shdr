varying vec3 pos;
uniform float power;
uniform vec2 offset;
uniform float juliaMode;

#define complexMult(a,b) vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x)
#define complexMag(z) float(pow(length(z), 2.0))
#define complexReciprocal(z) vec2(z.x / complexMag(z), -z.y / complexMag(z))
#define complexDivision(a,b) complexMult(a, complexReciprocal(b))
#define complexArg(z) float(atan(z.y, z.x))
#define complexLog(z) vec2(log(length(z)), complexArg(z))
#define complexExp(z) vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y))
#define sinh(x) float((exp(x) - exp(-x)) / 2.0)
#define cosh(x) float((exp(x) + exp(-x)) / 2.0)
#define complexSin(z) vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y))
#define complexCos(z) vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y))
#define complexTan(z) vec2(sin(2.0 * z.x)/(cos(2.0 * z.x) + cosh(2.0 * z.y)), sinh(2.0 * z.y)/(cos(2.0 * z.x) + cosh(2.0 * z.y)))
#define complexSinh(z) vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y))
#define complexCosh(z) vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y))
#define complexTanh(z) vec2(sinh(2.0 * z.x)/(cosh(2.0 * z.a) + cos(2.0 * z.y)), sin(2.0 * z.y)/(cosh(2.0 * z.x) + cos(2.0 * z.y)))
#define polar(r,a) vec2(cos(a) * r, sin(a) * r)
#define complexPower(z,p) vec2(polar(pow(length(z), float(p)), float(p) * complexArg(z)))

#define maxIterations 100.0
#define minIterations 3
#define _juliaMode (juliaMode > 0.5)

vec3 hsv2rgb(vec3 hsv) {
    float h, s, v, r, g, b, j, p, q, t;
    int i;
    vec3 color;
    
    h = hsv.x;
    s = hsv.y;
    v = hsv.z;
    
    if (h == 1.0) {
        h = 0.0;
    }
    
    if (v == 0.0) {
        // No brightness so return black
        color = vec3(0.0);
        
    } else if (s == 0.0) {
        // No saturation so return grey
        color = vec3(v);
        
    } else {
        // RGB color
        h *= 6.0;
        i = int(floor(h));
        j = h - float(i);
        p = v * (1.0 - s);
        q = v * (1.0 - (s * j));
        t = v * (1.0 - (s * (1.0 - j)));
        
        if (i == 0) {
            r = v;
            g = t;
            b = p;
        } else if (i == 1) {
            r = q;
            g = v;
            b = p;
        } else if (i == 2) {
            r = p;
            g = v;
            b = t;
        } else if (i == 3) {
            r = p;
            g = q;
            b = v;
        } else if (i == 4) {
            r = t;
            g = p;
            b = v;
        } else if (i == 5) {
            r = v;
            g = p;
            b = q;
        }
        color = vec3(r, g, b);
    }
    
    return color;
}

float Julia(vec2 z) {
    float n = 0.0;
    vec2  c = _juliaMode ? offset : z;
    
    for (int i = 0; i < int(maxIterations); i++) {
        n += 1.0;
        z = complexPower(z, power) + c;
        
        if (n >= float(minIterations) && (length(z) > 10.0)) {
            return n;
        }
    }
    
    return n;
}           

void main() {
    float c = log(Julia(vec2(pos.x, pos.y))) / log(maxIterations);
    vec3 color = hsv2rgb(vec3(c, 0.5, 1.0));
    gl_FragColor = vec4(color.x, // R
                        color.y, // G
                        color.z, // B
                        1.0);  // A

}
